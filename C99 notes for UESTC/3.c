/*
  switch-case的编译是随机定位行数，有两种定位方式：lookupswitch和tableswitch
  tableswitch是通过牺牲空间，换取时间O（1）通过数组的下标直接定位行数
  lookupswitch维护了key-value的关系，需要运行查找算法，最好是O（logN）查出case所在行数
  编译器自行判断用哪种定位
  一般情况下，switch-case比if-slse效率高（因为随机定位）
  
  因此，也可以理解case只是一个符号，执行时不会挨个case去检查，因此case是可以放在一起的（因为随机定位case后面的常量&final变量值，得出所在指令位置）
  所以case表达式可以聚合
  
  这也容易解释为什么case的里面需要加break：因为即便源代码看起来通过一个个case隔离开了代码段，但是实际上，case只是在编译时提醒这是一个候选常量的符号而已，到
  switch底层执行的时候，具体的指令位置是随机定位得到的，这时不同的代码段指令都是挨在一起的，switch（）的数值只管定位到某个位置，这之后的指令顺序执行，自然会连带
  着后面的case段一起执行；
  
  插入排序，从头处挨个比较与每个元素，O（n^2），一般用于数据量比较小的，稳定排序（可以选择相等时不换）
  shell排序，中等数据量的，复杂度和序列相关，每一次按照gap分组，组内插入排序，gap从N/2不断折半降到1，不稳定（因为是跳跃性的插入排序，不同组之间不交流）
  效率更高的原因是，gap从N/2逐渐降低的过程中，有序程度不断提高，高gap值下的一次交换，能抵得上插入排序的好几次比较
  
*/
